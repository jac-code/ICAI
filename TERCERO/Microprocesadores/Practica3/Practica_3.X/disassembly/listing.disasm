Disassembly Listing for Practica_3
Generated From:
C:/Users/jaime/Documents/GitHub/ICAI/TERCERO/Microprocesadores/Practica3/Practica_3.X/dist/default/debug/Practica_3.X.debug.elf
19-mar-2022 10:06:44

---  c:/users/jaime/documents/github/icai/tercero/microprocesadores/practica3/practica_3.x/seccion_2.c  -
1:                   #include <xc.h>
2:                   #include "Pic32Ini.h"
3:                   
4:                   #define BIT_LED0 0
5:                   #define BIT_LED1 1
6:                   #define BIT_LED2 2
7:                   #define BIT_LED3 3
8:                   
9:                   int main(void) {
9D000000  27BDFFF8   ADDIU SP, SP, -8
9D000004  AFBE0004   SW FP, 4(SP)
9D000008  03A0F021   ADDU FP, SP, ZERO
10:                      //configuramos LED 0 como salida
11:                      TRISC &= ~(1 << BIT_LED0);
9D00000C  3C02BF88   LUI V0, -16504
9D000010  8C426210   LW V0, 25104(V0)
9D000014  2404FFFE   ADDIU A0, ZERO, -2
9D000018  00441824   AND V1, V0, A0
9D00001C  3C02BF88   LUI V0, -16504
9D000020  AC436210   SW V1, 25104(V0)
12:                      
13:                      // configuramos LED 0 para que estÈ apagado
14:                      LATC |= (1 << BIT_LED0);
9D000024  3C02BF88   LUI V0, -16504
9D000028  8C426230   LW V0, 25136(V0)
9D00002C  34430001   ORI V1, V0, 1
9D000030  3C02BF88   LUI V0, -16504
9D000034  AC436230   SW V1, 25136(V0)
15:                      LATC |= (1 << BIT_LED1);
9D000038  3C02BF88   LUI V0, -16504
9D00003C  8C426230   LW V0, 25136(V0)
9D000040  34430002   ORI V1, V0, 2
9D000044  3C02BF88   LUI V0, -16504
9D000048  AC436230   SW V1, 25136(V0)
16:                      LATC |= (1 << 2);
9D00004C  3C02BF88   LUI V0, -16504
9D000050  8C426230   LW V0, 25136(V0)
9D000054  34430004   ORI V1, V0, 4
9D000058  3C02BF88   LUI V0, -16504
9D00005C  AC436230   SW V1, 25136(V0)
17:                      LATC &= ~(1 << BIT_LED3);
9D000060  3C02BF88   LUI V0, -16504
9D000064  8C426230   LW V0, 25136(V0)
9D000068  2404FFF7   ADDIU A0, ZERO, -9
9D00006C  00441824   AND V1, V0, A0
9D000070  3C02BF88   LUI V0, -16504
9D000074  AC436230   SW V1, 25136(V0)
18:                      LATC |= (1 << BIT_LED3);
9D000078  3C02BF88   LUI V0, -16504
9D00007C  8C426230   LW V0, 25136(V0)
9D000080  34430008   ORI V1, V0, 8
9D000084  3C02BF88   LUI V0, -16504
9D000088  AC436230   SW V1, 25136(V0)
19:                      
20:                      T2CON = 0; // se para el temporizador 2
9D00008C  3C02BF80   LUI V0, -16512
9D000090  AC400800   SW ZERO, 2048(V0)
21:                      TMR2 = 0; // se pone la cuenta a 0
9D000094  3C02BF80   LUI V0, -16512
9D000098  AC400810   SW ZERO, 2064(V0)
22:                      IFS0bits.T2IF = 0; // se borra el bit de fin de cuenta
9D00009C  3C03BF88   LUI V1, -16504
9D0000A0  8C621030   LW V0, 4144(V1)
9D0000A4  7C024A44   INS V0, ZERO, 9, 1
9D0000A8  AC621030   SW V0, 4144(V1)
23:                      
24:                      /* CALCULO DEL VALOR PR2 */
25:                      // 1 Hz = periodo completo, por lo tanto,
26:                      // LED encendido 0.5 seg
27:                      // LED apagado 0.5 seg
28:                      // PR2 = (retardo / (div * 200 ns)) - 1 --> <= 65535
29:                      // en este caso tenemos PR2 = (0.5 seg / (64 * 200 ns)) - 1 = 39061
30:                      
31:                      PR2 = 39061;
9D0000AC  3C02BF80   LUI V0, -16512
9D0000B0  34039895   ORI V1, ZERO, -26475
9D0000B4  AC430820   SW V1, 2080(V0)
32:                      T2CON = 0x8060; // Timer 2 --> ON = 1 + reloj interno + prescaler = 64
9D0000B8  3C02BF80   LUI V0, -16512
9D0000BC  34038060   ORI V1, ZERO, -32672
9D0000C0  AC430800   SW V1, 2048(V0)
33:                      
34:                      while(1) {
35:                          if(IFS0bits.T2IF == 1) {
9D0000C4  3C02BF88   LUI V0, -16504
9D0000C8  8C421030   LW V0, 4144(V0)
9D0000CC  30420200   ANDI V0, V0, 512
9D0000D0  1040000C   BEQ V0, ZERO, 0x9D000104
9D0000D4  00000000   NOP
36:                              // invertimos el valor del LED 0
37:                              LATC ^= 1;
9D0000D8  3C02BF88   LUI V0, -16504
9D0000DC  8C426230   LW V0, 25136(V0)
9D0000E0  38430001   XORI V1, V0, 1
9D0000E4  3C02BF88   LUI V0, -16504
9D0000E8  AC436230   SW V1, 25136(V0)
38:                              // borramos el flag del Timer 2
39:                              IFS0bits.T2IF = 0;
9D0000EC  3C03BF88   LUI V1, -16504
9D0000F0  8C621030   LW V0, 4144(V1)
9D0000F4  7C024A44   INS V0, ZERO, 9, 1
9D0000F8  AC621030   SW V0, 4144(V1)
40:                          }
41:                      }
9D0000FC  0B400031   J 0x9D0000C4
9D000100  00000000   NOP
9D000104  0B400031   J 0x9D0000C4
9D000108  00000000   NOP
42:                      
43:                      return 0;
44:                  }
45:                  
46:                  void apagar_led(int led) {
9D00010C  27BDFFF8   ADDIU SP, SP, -8
9D000110  AFBE0004   SW FP, 4(SP)
9D000114  03A0F021   ADDU FP, SP, ZERO
9D000118  AFC40008   SW A0, 8(FP)
47:                      if(led >= 0) {
9D00011C  8FC20008   LW V0, 8(FP)
9D000120  0440000A   BLTZ V0, 0x9D00014C
9D000124  00000000   NOP
48:                          LATC |= (1 << led);
9D000128  24030001   ADDIU V1, ZERO, 1
9D00012C  8FC20008   LW V0, 8(FP)
9D000130  00431004   SLLV V0, V1, V0
9D000134  00401821   ADDU V1, V0, ZERO
9D000138  3C02BF88   LUI V0, -16504
9D00013C  8C426230   LW V0, 25136(V0)
9D000140  00621825   OR V1, V1, V0
9D000144  3C02BF88   LUI V0, -16504
9D000148  AC436230   SW V1, 25136(V0)
49:                      }
50:                  }
9D00014C  03C0E821   ADDU SP, FP, ZERO
9D000150  8FBE0004   LW FP, 4(SP)
9D000154  27BD0008   ADDIU SP, SP, 8
9D000158  03E00008   JR RA
9D00015C  00000000   NOP
51:                  
52:                  void encender_led(int led) {
9D000160  27BDFFF8   ADDIU SP, SP, -8
9D000164  AFBE0004   SW FP, 4(SP)
9D000168  03A0F021   ADDU FP, SP, ZERO
9D00016C  AFC40008   SW A0, 8(FP)
53:                      if(led >= 0) {
9D000170  8FC20008   LW V0, 8(FP)
9D000174  0440000B   BLTZ V0, 0x9D0001A4
9D000178  00000000   NOP
54:                          LATC &= ~(1 << led);
9D00017C  24030001   ADDIU V1, ZERO, 1
9D000180  8FC20008   LW V0, 8(FP)
9D000184  00431004   SLLV V0, V1, V0
9D000188  00021027   NOR V0, ZERO, V0
9D00018C  00401821   ADDU V1, V0, ZERO
9D000190  3C02BF88   LUI V0, -16504
9D000194  8C426230   LW V0, 25136(V0)
9D000198  00621824   AND V1, V1, V0
9D00019C  3C02BF88   LUI V0, -16504
9D0001A0  AC436230   SW V1, 25136(V0)
55:                      }
56:                  }
9D0001A4  03C0E821   ADDU SP, FP, ZERO
9D0001A8  8FBE0004   LW FP, 4(SP)
9D0001AC  27BD0008   ADDIU SP, SP, 8
9D0001B0  03E00008   JR RA
9D0001B4  00000000   NOP
---  c:/users/jaime/documents/github/icai/tercero/microprocesadores/practica3/practica_3.x/pic32ini.c  --
1:                   #include <xc.h>
2:                   #include "Pic32Ini.h"
3:                   
4:                   // Configuration bits: selected in the GUI (MCC)
5:                   
6:                   // DEVCFG3
7:                   #pragma config PMDL1WAY = ON    // Peripheral Module Disable Configuration->Allow only one reconfiguration
8:                   #pragma config IOL1WAY = ON    // Peripheral Pin Select Configuration->Allow only one reconfiguration
9:                   #pragma config FUSBIDIO = ON    // USB USID Selection->Controlled by the USB Module
10:                  #pragma config FVBUSONIO = ON    // USB VBUS ON Selection->Controlled by USB Module
11:                  
12:                  // DEVCFG2
13:                  #pragma config FPLLIDIV = DIV_2    // PLL Input Divider->2x Divider
14:                  #pragma config FPLLMUL = MUL_20    // PLL Multiplier->20x Multiplier
15:                  #pragma config UPLLIDIV = DIV_12    // USB PLL Input Divider->12x Divider
16:                  #pragma config UPLLEN = OFF    // USB PLL Enable->Disabled and Bypassed
17:                  #pragma config FPLLODIV = DIV_2    // System PLL Output Clock Divider->PLL Divide by 2
18:                  
19:                  // DEVCFG1
20:                  #pragma config FNOSC = PRIPLL    // Oscillator Selection Bits->Primary Osc w/PLL (XT+,HS+,EC+PLL)
21:                  #pragma config FSOSCEN = OFF    // Secondary Oscillator Enable->Disabled
22:                  #pragma config IESO = ON    // Internal/External Switch Over->Enabled
23:                  #pragma config POSCMOD = XT    // Primary Oscillator Configuration->XT osc mode
24:                  #pragma config OSCIOFNC = OFF    // CLKO Output Signal Active on the OSCO Pin->Disabled
25:                  #pragma config FPBDIV = DIV_8    // Peripheral Clock Divisor->Pb_Clk is Sys_Clk/8
26:                  #pragma config FCKSM = CSDCMD    // Clock Switching and Monitor Selection->Clock Switch Disable, FSCM Disabled
27:                  #pragma config WDTPS = PS1048576    // Watchdog Timer Postscaler->1:1048576
28:                  #pragma config WINDIS = OFF    // Watchdog Timer Window Enable->Watchdog Timer is in Non-Window Mode
29:                  #pragma config FWDTEN = OFF    // Watchdog Timer Enable->WDT Disabled (SWDTEN Bit Controls)
30:                  #pragma config FWDTWINSZ = WINSZ_25    // Watchdog Timer Window Size->Window Size is 25%
31:                  
32:                  // DEVCFG0
33:                  #pragma config DEBUG = OFF    // Background Debugger Enable->Debugger is Disabled
34:                  #pragma config JTAGEN = ON    // JTAG Enable->JTAG Port Enabled
35:                  #pragma config ICESEL = ICS_PGx1    // ICE/ICD Comm Channel Select->Communicate on PGEC1/PGED1
36:                  #pragma config PWP = OFF    // Program Flash Write Protect->Disable
37:                  #pragma config BWP = OFF    // Boot Flash Write Protect bit->Protection Disabled
38:                  #pragma config CP = OFF    // Code Protect->Protection Disabled
39:                  
40:                  
41:                  void InicializarReloj(void)
42:                  {
9D000318  27BDFFF8   ADDIU SP, SP, -8
9D00031C  AFBE0004   SW FP, 4(SP)
9D000320  03A0F021   ADDU FP, SP, ZERO
43:                      SYSKEY = 0x0;         // Nos aseguramos que OSCCON est√° bloqueado
9D000324  3C02BF81   LUI V0, -16511
9D000328  AC40F230   SW ZERO, -3536(V0)
44:                      SYSKEY = 0xAA996655;  // Se escribe la primera clave en SYSKEY
9D00032C  3C02BF81   LUI V0, -16511
9D000330  3C03AA99   LUI V1, -21863
9D000334  34636655   ORI V1, V1, 26197
9D000338  AC43F230   SW V1, -3536(V0)
45:                      SYSKEY = 0x556699AA;  // Se escribe la segunda clave en SYSKEY
9D00033C  3C02BF81   LUI V0, -16511
9D000340  3C035566   LUI V1, 21862
9D000344  346399AA   ORI V1, V1, -26198
9D000348  AC43F230   SW V1, -3536(V0)
46:                      //  Ahora OSCCON est√° desbloqueado y podemos modificarlo
47:                      
48:                      // Se configura el reloj para usar el oscilador externo usando PLL.
49:                      // El oscilador est√° dividido entre 2, pues el PLL ha de tener una entrada
50:                      // entre 4 y 5 MHz (DEVCFG3.FPLLIDIV = 001).
51:                      // Al PLL entran por tanto 8MHz/2 = 4 MHz, luego el PLL lo
52:                      // Multiplica por 20 (80 MHz) y esta salida se divide entre 2 para 
53:                      // obtener un reloj principal a 40 MHz. Este reloj se divide por 8 para
54:                      // obtener el reloj del bus de perif√©ricos. Para ello, en el
55:                      // registro OSCCON se hace:
56:                      // PLLODIV = 001 (div. por 2)
57:                      // PBDIV = 11 (div. por 8)
58:                      // PLLMULT = 101 (mult. por 20)
59:                      // COSC = 011 (Oscilador principal con PLL)
60:                      // NOSC = 011 (Oscilador principal con PLL)
61:                      OSCCON = 0x081D3300;
9D00034C  3C02BF81   LUI V0, -16511
9D000350  3C03081D   LUI V1, 2077
9D000354  34633300   ORI V1, V1, 13056
9D000358  AC43F000   SW V1, -4096(V0)
62:                  
63:                      // Una vez hemos terminado, lo volvemos a bloquear
64:                      SYSKEY = 0x0;
9D00035C  3C02BF81   LUI V0, -16511
9D000360  AC40F230   SW ZERO, -3536(V0)
65:                  }
9D000364  03C0E821   ADDU SP, FP, ZERO
9D000368  8FBE0004   LW FP, 4(SP)
9D00036C  27BD0008   ADDIU SP, SP, 8
9D000370  03E00008   JR RA
9D000374  00000000   NOP
---  C:/Program Files/Microchip/MPLABX/v5.45/packs/Microchip/PIC32MX_DFP/1.3.231/xc32/startup/crt0.S  ---
                                                  1:     /*********************************************************************
                                                  2:      *
                                                  3:      *                  C Runtime Startup
                                                  4:      *
                                                  5:      *********************************************************************
                                                  6:      * Filename:        crt0.S
                                                  7:      *
                                                  8:      * Processor:       PIC32
                                                  9:      *
                                                  10:     * Compiler:        MPLAB XC32
                                                  11:     *                  MPLAB X IDE
                                                  12:     * Company:         Microchip Technology Inc.
                                                  13:     *
                                                  14:     * Software License Agreement
                                                  15:     *
                                                  16:     * Copyright (c) 2014, Microchip Technology Inc. and its subsidiaries ("Microchip")
                                                  17:     * All rights reserved.
                                                  18:     *
                                                  19:     * This software is developed by Microchip Technology Inc. and its
                                                  20:     * subsidiaries ("Microchip").
                                                  21:     *
                                                  22:     * Redistribution and use in source and binary forms, with or without
                                                  23:     * modification, are permitted provided that the following conditions are met:
                                                  24:     *
                                                  25:     * 1.      Redistributions of source code must retain the above copyright
                                                  26:     * notice, this list of conditions and the following disclaimer.
                                                  27:     *
                                                  28:     * 2.      Redistributions in binary form must reproduce the above copyright
                                                  29:     * notice, this list of conditions and the following disclaimer in the
                                                  30:     * documentation and/or other materials provided with the distribution.
                                                  31:     *
                                                  32:     * 3.      Microchip's name may not be used to endorse or promote products
                                                  33:     * derived from this software without specific prior written permission.
                                                  34:     *
                                                  35:     * THIS SOFTWARE IS PROVIDED BY MICROCHIP "AS IS" AND ANY EXPRESS OR IMPLIED
                                                  36:     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
                                                  37:     * MERCHANTABILITY AND FITNESS FOR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
                                                  38:     * MICROCHIP BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                                                  39:     * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING BUT NOT LIMITED TO
                                                  40:     * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA OR PROFITS;
                                                  41:     * OR BUSINESS INTERRUPTION) HOWSOEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                                                  42:     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
                                                  43:     * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
                                                  44:     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                  45:     *
                                                  46:     ********************************************************************/
                                                  47:    
                                                  48:    #include "xc.h"
                                                  49:    #include <cp0defs.h>
                                                  50:    
                                                  51:    #ifdef __LIBBUILD__
                                                  52:       # Replace the standard debugging information with a simple filename. This
                                                  53:       # prevents the library build directory from showing up in MPLAB IDE. It
                                                  54:       # also effectively disables source-line debugging.
                                                  55:       .file 1 "libpic32/startup/crt0.S"
                                                  56:       .loc 1 0
                                                  57:    #endif
                                                  58:    
                                                  59:    #if (__XC32_VERSION > 1000) && !defined(CPP_INIT)
                                                  60:    #define CPP_INIT
                                                  61:    #endif
                                                  62:    
                                                  63:    #if !defined(PIC32_SRS_SET_COUNT)
                                                  64:    #  if defined(__PIC32_SRS_SET_COUNT)
                                                  65:    #    define PIC32_SRS_SET_COUNT __PIC32_SRS_SET_COUNT
                                                  66:    #  else
                                                  67:    #    warning PIC32_SRS_SET_COUNT not defined on build line
                                                  68:    #    define PIC32_SRS_SET_COUNT 2
                                                  69:    #  endif
                                                  70:    #endif
                                                  71:    
                                                  72:    #if defined(__PIC32MX) || defined(__PIC32MM) || defined(__PIC32MZ)
                                                  73:    #define INIT_DATA 1
                                                  74:    #endif
                                                  75:    
                                                  76:    /* This file contains 32-bit assembly code */
                                                  77:           .set nomips16
                                                  78:    
                                                  79:            ##################################################################
                                                  80:            # Entry point of the entire application
                                                  81:            ##################################################################
                                                  82:            .section .reset,code,keep
                                                  83:            .align 2
                                                  84:            .set noreorder
                                                  85:            .ent _reset
                                                  86:    
                                                  87:    ############################
                                                  88:    # Begin ISA switching code #
                                                  89:    ############################
                                                  90:    
                                                  91:    #if defined (__mips_micromips)
                                                  92:            .set micromips
                                                  93:    #endif
                                                  94:    
                                                  95:    #if (defined(__PIC32_HAS_MICROMIPS)) && (defined(__PIC32_HAS_MIPS32R2))
                                                  96:    _reset:
                                                  97:            .word 0x10000003     /* MIPS32:    branch forward 0x10 bytes from here  */
                                                  98:                                 /* MicroMIPS: ADDI32 $0, $0, 0x0007 (nop)          */
                                                  99:                                 /* DO NOT change the relative branch               */
                                                  100:   
                                                  101:           .word 0x00000000     /* NOP */
                                                  102:   __reset_micromips_isa:
                                                  103:           .set    micromips
                                                  104:           jal     _startup
                                                  105:           nop
                                                  106:   
                                                  107:           .align 2
                                                  108:           /* Device not in proper ISA mode */
                                                  109:           .set nomicromips
                                                  110:   __reset_switch_isa:
                                                  111:           jal _startup
                                                  112:           nop
                                                  113:   
                                                  114:   #else
                                                  115:   
                                                  116:   _reset:
BFC00000  0FF00002   JAL 0xBFC00008               117:           jal _startup
BFC00004  00000000   NOP                          118:           nop
                                                  119:   
                                                  120:   #endif  /* __PIC32_HAS_MICROMIPS */
                                                  121:   
                                                  122:           .align 2
                                                  123:           .end _reset
                                                  124:           .globl _reset
                                                  125:           .size _reset, .-_reset
                                                  126:   
                                                  127:           .section .reset.startup,code,keep
                                                  128:           .align 2
                                                  129:           .set noreorder
                                                  130:   
                                                  131:   #if defined (__mips_micromips)
                                                  132:           .set micromips
                                                  133:   #else
                                                  134:           .set nomicromips
                                                  135:   #endif
                                                  136:   
                                                  137:   ############################
                                                  138:   # End ISA switching code   #
                                                  139:   ############################
                                                  140:   
                                                  141:           ##################################################################
                                                  142:           # Startup code
                                                  143:           ##################################################################
                                                  144:           .align 2
                                                  145:           .globl _startup
                                                  146:           .set noreorder
                                                  147:           .ent _startup
                                                  148:   _startup:
                                                  149:           ##################################################################
                                                  150:           # If entered because of an NMI, jump to the NMI handler.
                                                  151:           ##################################################################
BFC00008  401A6000   MFC0 K0, Status              152:           mfc0    k0,_CP0_STATUS
BFC0000C  7F5A04C0   EXT K0, K0, 19, 1            153:           ext     k0,k0,19,1              # Extract NMI bit
BFC00010  13400005   BEQ K0, ZERO, 0xBFC00028     154:           beqz    k0,_no_nmi
BFC00014  00000000   NOP                          155:           nop
BFC00018  3C1A9D00   LUI K0, -25344               156:           la      k0,_nmi_handler
BFC00020  03400008   JR K0                        157:           jr      k0
BFC00024  00000000   NOP                          158:           nop
                                                  159:   _no_nmi:
                                                  160:   
                                                  161:           ##################################################################
                                                  162:           # Initialize Stack Pointer
                                                  163:           #   _stack is initialized by the linker script to point to the
                                                  164:           #    starting location of the stack in DRM
                                                  165:           ##################################################################
BFC00028  3C1DA000   LUI SP, -24576               166:           la      sp,_stack
                                                  167:   
                                                  168:           ##################################################################
                                                  169:           # Initialize Global Pointer
                                                  170:           #   _gp is initialized by the linker script to point to "middle"
                                                  171:           #   of the small variables region
                                                  172:           ##################################################################
BFC00030  3C1CA001   LUI GP, -24575               173:           la      gp,_gp
                                                  174:   
                                                  175:   #if (PIC32_SRS_SET_COUNT == 2)
                                                  176:           ##################################################################
                                                  177:           # Initialize Global Pointer in Shadow Set
                                                  178:           #   The SRSCtl's PSS field must be set to the shadow set in which
                                                  179:           #   to initialize the global pointer.  Since we have only a
                                                  180:           #   single shadow set (besides the normal), we will initialize
                                                  181:           #   SRSCtl<PSS> to SRSCtl<HSS>.  We then write the global pointer
                                                  182:           #   to the previous shadow set to ensure that on interrupt, the
                                                  183:           #   global pointer has been initialized.
                                                  184:           ##################################################################
                                                  185:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
                                                  186:           add     t3,t1,zero              # Save off current SRSCtl
                                                  187:           ext     t2,t1,26,4              # to obtain HSS field
                                                  188:           ins     t1,t2,6,4               # Put HSS field
                                                  189:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
                                                  190:           ehb                             # Clear hazard before using new SRSCTL
                                                  191:           wrpgpr  gp,gp                   # Set global pointer in PSS
                                                  192:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
                                                  193:           ehb
                                                  194:   
                                                  195:   #elif (PIC32_SRS_SET_COUNT > 2)
                                                  196:           ##################################################################
                                                  197:           # Initialize Global Pointer in Shadow Set(s)
                                                  198:           #   The SRSCtl PSS field must be set to the shadow set in which
                                                  199:           #   to initialize the global pointer.  We will initialize
                                                  200:           #   SRSCtl<PSS> to the number of reg sets and work down to set zero.
                                                  201:           #   We write the global pointer to the previous shadow set to
                                                  202:           #   ensure that on interrupt, the global pointer has been
                                                  203:           #   initialized.
                                                  204:           ##################################################################
                                                  205:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
                                                  206:           add     t3,t1,zero              # Save off current SRSCtl
                                                  207:   
                                                  208:           li      t2,(PIC32_SRS_SET_COUNT-1)
                                                  209:   
                                                  210:   1:      ins     t1,t2,6,4               # Put next shadow set field
                                                  211:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
                                                  212:           ehb                             # Clear hazard before using new SRSCTL
                                                  213:           wrpgpr  gp,gp                   # Set global pointer in PSS
                                                  214:   
                                                  215:           addiu   t2,t2,-1                # Next lower shadow set
                                                  216:                                           # Loop for all sets
                                                  217:           bne     t2,$0,1b                # Down to zero (normal GPR set)
                                                  218:           nop
                                                  219:   
                                                  220:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
                                                  221:           ehb
                                                  222:   
                                                  223:   #endif /* (PIC32_SRS_SET_COUNT > 2) */
                                                  224:   
                                                  225:           ##################################################################
                                                  226:           # Call the "on reset" procedure
                                                  227:           ##################################################################
BFC00038  3C089D00   LUI T0, -25344               228:           la      t0,_on_reset
BFC00040  0100F809   JALR T0                      229:           jalr    t0
BFC00044  00000000   NOP                          230:           nop
                                                  231:   
                                                  232:   #if defined(INIT_MMU_MZ_FIXED) || defined(__PIC32_HAS_MMU_MZ_FIXED)
                                                  233:           ##################################################################
                                                  234:           # Initialize TLB for fixed mapping to EBI and SQI
                                                  235:           ##################################################################
                                                  236:           .extern __pic32_tlb_init_ebi_sqi
                                                  237:           la      t0,__pic32_tlb_init_ebi_sqi
                                                  238:           jalr    t0
                                                  239:           nop
                                                  240:   #endif
                                                  241:   
                                                  242:           ##################################################################
                                                  243:           # Clear uninitialized data sections
                                                  244:           ##################################################################
                                                  245:   _start_bss_init:
BFC00048  3C08A000   LUI T0, -24576               246:           la      t0,_bss_begin
BFC00050  3C09A000   LUI T1, -24576               247:           la      t1,_bss_end
BFC00058  10000003   BEQ ZERO, ZERO, 0xBFC00068   248:           b       _bss_check
BFC0005C  00000000   NOP                          249:           nop
                                                  250:   
                                                  251:   _bss_init:
BFC00060  AD000000   SW ZERO, 0(T0)               252:           sw      zero,0x0(t0)
BFC00064  25080004   ADDIU T0, T0, 4              253:           addu    t0,4
                                                  254:   _bss_check:
BFC00068  0109082B   SLTU AT, T0, T1              255:           bltu    t0,t1,_bss_init
BFC00070  00000000   NOP                          256:           nop
                                                  257:   
                                                  258:   #if defined(INIT_L1_CACHE) || defined(__PIC32_HAS_L1CACHE)
                                                  259:           ##################################################################
                                                  260:           # Initialize L1 cache. This must be done after bss clearing
                                                  261:           # since the _bss_end symbol may not be cache-line aligned.
                                                  262:           ##################################################################
                                                  263:           .extern   __pic32_init_cache
                                                  264:           la      t0,__pic32_init_cache
                                                  265:           jalr    t0
                                                  266:           nop
                                                  267:   #endif
                                                  268:   
                                                  269:   #if defined(INIT_DATA) || defined(__PIC32_HAS_INIT_DATA)
                                                  270:   
                                                  271:   #if defined(__LIBBUILD__) /* Prebuilt crt0.o file */
                                                  272:   
                                                  273:           ##################################################################
                                                  274:           # Initialize data using the linker-generated .dinit table
                                                  275:           # For use with XC32 versions prior to XC32 v2.10 only.
                                                  276:           ##################################################################
                                                  277:           .equiv FMT_CLEAR,0
                                                  278:           .equiv FMT_COPY,1
                                                  279:   _dinit_init:
                                                  280:           la      t0,_dinit_addr
                                                  281:   
                                                  282:   #define SRC t0
                                                  283:   #define DST t1
                                                  284:   #define LEN t2
                                                  285:   #define FMT t3
                                                  286:   
                                                  287:   0:      lw      DST,0(SRC)
                                                  288:           beqz    DST,9f
                                                  289:           addu    SRC,4
                                                  290:           lw      LEN,0(SRC)
                                                  291:           addu    SRC,4
                                                  292:           lw      FMT,0(SRC)
                                                  293:           beq     FMT,$0,_dinit_clear
                                                  294:           addu    SRC,4
                                                  295:   
                                                  296:   _dinit_copy:
                                                  297:           lbu     t4,0(SRC)
                                                  298:           subu    LEN,1
                                                  299:           addu    SRC,1
                                                  300:           sb      t4,0(DST)
                                                  301:           bne     LEN,$0,_dinit_copy
                                                  302:           addu    DST,1
                                                  303:   
                                                  304:           b       _dinit_end
                                                  305:           nop
                                                  306:   
                                                  307:   _dinit_clear:
                                                  308:           sb      $0,(DST)
                                                  309:           subu    LEN,1
                                                  310:           bne     LEN,$0,_dinit_clear
                                                  311:           addu    DST,1
                                                  312:   
                                                  313:   _dinit_end:
                                                  314:           addu    SRC,3
                                                  315:           addiu   LEN,$0,-4
                                                  316:           and     SRC,LEN,SRC
                                                  317:           lw      DST,0(SRC)
                                                  318:           bne     DST,$0,0b
                                                  319:           nop
                                                  320:   9:
                                                  321:   
                                                  322:   #else
                                                  323:           #####################################################################
                                                  324:           # Initialize data using the linker-generated .dinit table
                                                  325:           # XC32 v2.10 and later provide the data-init code in a separate file
                                                  326:           # packaged with the compiler rather than the DFP. Use that init
                                                  327:           # code instead.
                                                  328:           #####################################################################
                                                  329:           .extern   __pic32_data_init
BFC00074  3C089D00   LUI T0, -25344               330:           la      t0, __pic32_data_init
BFC0007C  0100F809   JALR T0                      331:           jalr    t0
BFC00080  00000000   NOP                          332:           nop
                                                  333:   
                                                  334:   #if defined(_OFF168_VOFF_POSITION)
                                                  335:           lui	t1,%hi(OFF168)
                                                  336:           lui	t2,%hi(__vector_offset_168)
                                                  337:           addiu	t2,t2,%lo(__vector_offset_168)
                                                  338:           sw	t2,%lo(OFF168)(t1)
                                                  339:   #endif
                                                  340:   
                                                  341:   #endif /* __LIBBUILD__ */
                                                  342:   
                                                  343:   #endif /* INIT_DATA */
                                                  344:   
                                                  345:           ##################################################################
                                                  346:           # If there are no RAM functions, skip the next section --
                                                  347:           # initializing bus matrix registers.
                                                  348:           ##################################################################
BFC00084  3C090000   LUI T1, 0                    349:           la      t1,_ramfunc_begin
BFC0008C  11200010   BEQ T1, ZERO, 0xBFC000D0     350:           beqz    t1,_ramfunc_done
BFC00090  00000000   NOP                          351:           nop
                                                  352:   
                                                  353:   #if defined(INIT_SSX) || defined(__PIC32_HAS_SSX)
                                                  354:     /* No initialization required */
                                                  355:   #else /* Use BMX */
                                                  356:           ##################################################################
                                                  357:           # Initialize bus matrix registers if RAM functions exist in the
                                                  358:           # application
                                                  359:           ##################################################################
BFC00094  3C090000   LUI T1, 0                    360:           la      t1,_bmxdkpba_address
BFC0009C  3C0ABF88   LUI T2, -16504               361:           la      t2,BMXDKPBA
BFC000A4  AD490000   SW T1, 0(T2)                 362:           sw      t1,0(t2)
BFC000A8  3C090000   LUI T1, 0                    363:           la      t1,_bmxdudba_address
BFC000B0  3C0ABF88   LUI T2, -16504               364:           la      t2,BMXDUDBA
BFC000B8  AD490000   SW T1, 0(T2)                 365:           sw      t1,0(t2)
BFC000BC  3C090000   LUI T1, 0                    366:           la      t1,_bmxdupba_address
BFC000C4  3C0ABF88   LUI T2, -16504               367:           la      t2,BMXDUPBA
BFC000CC  AD490000   SW T1, 0(T2)                 368:           sw      t1,0(t2)
                                                  369:   #endif /* INIT_SSX */
                                                  370:   
                                                  371:   _ramfunc_done:
                                                  372:   
                                                  373:           ##################################################################
                                                  374:           # Initialize CP0 registers
                                                  375:           ##################################################################
                                                  376:           # Initialize Count register
                                                  377:           ##################################################################
BFC000D0  40804800   MTC0 ZERO, Count             378:           mtc0    zero,_CP0_COUNT
                                                  379:   
                                                  380:           ##################################################################
                                                  381:           # Initialize Compare register
                                                  382:           ##################################################################
BFC000D4  240AFFFF   ADDIU T2, ZERO, -1           383:           li      t2,-1
BFC000D8  408A5800   MTC0 T2, Compare             384:           mtc0    t2,_CP0_COMPARE
                                                  385:   
                                                  386:           ##################################################################
                                                  387:           # Ensure BEV set and Initialize EBase register
                                                  388:           ##################################################################
BFC000DC  3C080040   LUI T0, 64                   389:           li      t0, (1<<22)
BFC000E0  400A6000   MFC0 T2, Status              390:           mfc0    t2,_CP0_STATUS
BFC000E4  010A5025   OR T2, T0, T2                391:           or      t2,t0,t2               # Set BEV bit 22
BFC000E8  408A6000   MTC0 T2, Status              392:           mtc0    t2,_CP0_STATUS
                                                  393:   
BFC000EC  3C099D01   LUI T1, -25343               394:           la      t1,_ebase_address
BFC000F4  000000C0   EHB                          395:           ehb
BFC000F8  40897801   MTC0 T1, EBase               396:           mtc0    t1,_CP0_EBASE
                                                  397:           
                                                  398:           ##################################################################
                                                  399:           # Initialize PRISS register to a safer default for devices that 
                                                  400:           # have it. The application should re-initialize it to an
                                                  401:           # application-specific value.
                                                  402:           #
                                                  403:           # We do NOT do this by default.
                                                  404:           ##################################################################
                                                  405:   #if defined(USE_DEFAULT_PRISS_VALUE) 
                                                  406:   #if defined(_PRISS_PRI7SS_POSITION)
                                                  407:   #if (PIC32_SRS_SET_COUNT >= 7)
                                                  408:           li	    t2, 0x76540000
                                                  409:           addiu	t2, t2, 0x3210
                                                  410:           lui	    t1, %hi(PRISS)
                                                  411:           sw	    t2, %lo(PRISS)(t1)
                                                  412:   #elif (PIC32_SRS_SET_COUNT <= 2)
                                                  413:           li	    t2, 0x10000000
                                                  414:           lui	    t1, %hi(PRISS)
                                                  415:           sw	    t2, %lo(PRISS)(t1)
                                                  416:   #endif /* PIC32_SRS_SET_COUNT */
                                                  417:   #endif /* _PRISS_PRI7SS_POSITION */
                                                  418:   #endif /* USE_DEFAULT_PRISS_VALUE */
                                                  419:           
                                                  420:           ##################################################################
                                                  421:           # Initialize IntCtl/INTCON.VS register with _vector_spacing
                                                  422:           ##################################################################
BFC000FC  3C090000   LUI T1, 0                    423:           la      t1,_vector_spacing
                                                  424:   #if defined(INIT_INTCONVS) || defined(__PIC32_HAS_INTCONVS)
                                                  425:           la      t0, INTCON
                                                  426:           lw      t2, 0(t0)
                                                  427:           li      t2, 0
                                                  428:           ins     t2, t1, 16, 7
                                                  429:   #if defined(__PIC32MM) && defined(_INTCON_MVEC_MASK)
                                                  430:           ori     t2, t2, _INTCON_MVEC_MASK
                                                  431:   #endif
                                                  432:           sw      t2, 0(t0)
                                                  433:   #endif
BFC00104  240A0000   ADDIU T2, ZERO, 0            434:           li      t2,0                    # Clear t2 and
BFC00108  7D2A4944   INS T2, T1, 5, 5             435:           ins     t2,t1,5,5               # shift value to VS field
BFC0010C  408A6001   MTC0 T2, IntCtl              436:           mtc0    t2,_CP0_INTCTL
                                                  437:   
                                                  438:           ##################################################################
                                                  439:           # Initialize CAUSE registers
                                                  440:           # - Enable counting of Count register <DC = 0>
                                                  441:           # - Use special exception vector <IV = 1>
                                                  442:           # - Clear pending software interrupts <IP1:IP0 = 0>
                                                  443:           ##################################################################
BFC00110  3C090080   LUI T1, 128                  444:           li      t1,0x00800000
BFC00114  40896800   MTC0 T1, Cause               445:           mtc0    t1,_CP0_CAUSE
                                                  446:   
                                                  447:           ##################################################################
                                                  448:           # Initialize STATUS register
                                                  449:           # - Access to Coprocessor 0 not allowed in user mode <CU0 = 0>
                                                  450:           # - User mode uses configured endianness <RE = 0>
                                                  451:           # - Preserve Bootstrap Exception vectors <BEV>
                                                  452:           # - Preserve soft reset <SR> and non-maskable interrupt <NMI>
                                                  453:           # - CorExtend enabled based on whether CorExtend User Defined
                                                  454:           #   Instructions have been implemented <CEE = Config<UDI>>
                                                  455:           # - Disable any pending interrupts <IM7..IM2 = 0, IM1..IM0 = 0>
                                                  456:           # - Disable hardware interrupts <IPL7:IPL2 = 0>
                                                  457:           # - Base mode is Kernel mode <UM = 0>
                                                  458:           # - Error level is normal <ERL = 0>
                                                  459:           # - Exception level is normal <EXL = 0>
                                                  460:           # - Interrupts are disabled <IE = 0>
                                                  461:           # - DSPr2 ASE is enabled for devices that support it <MX = 1>
                                                  462:           # - FPU64 is enabled for devices that support it <CU1=1> & <FR=1>
                                                  463:           ##################################################################
BFC00118  40088000   MFC0 T0, Config              464:           mfc0    t0,_CP0_CONFIG
BFC0011C  7D090580   EXT T1, T0, 22, 1            465:           ext     t1,t0,22,1              # Extract UDI from Config register
BFC00120  00094C40   SLL T1, T1, 17               466:           sll     t1,t1,17                # Move UDI to Status.CEE location
BFC00124  40086000   MFC0 T0, Status              467:           mfc0    t0,_CP0_STATUS
BFC00128  3C010058   LUI AT, 88                   468:           and     t0,t0,0x00580000        # Preserve SR, NMI, and BEV
                                                  469:   #if defined(INIT_DSPR2) || defined(__PIC32_HAS_DSPR2)
                                                  470:           li      t2, 0x01000000          # Set the Status.MX bit to enable DSP
                                                  471:           or      t0,t2,t0
                                                  472:   #endif
                                                  473:   #if defined(INIT_FPU64) || defined(__PIC32_HAS_FPU64)
                                                  474:           li      t2, 0x24000000          # Set the Status.CU1 and Status.FR bits to
                                                  475:           or      t0,t2,t0                # enable the FPU in FR64 mode
                                                  476:   #endif
                                                  477:   
BFC00130  01284025   OR T0, T1, T0                478:           or      t0,t1,t0                # Include Status.CEE (from UDI)
BFC00134  40886000   MTC0 T0, Status              479:           mtc0    t0,_CP0_STATUS
                                                  480:           
                                                  481:   #if defined(PIC32WK) && defined(_CP0_CONFIG3) && defined (__mips_micromips)
                                                  482:           # Ensure that the ISAONEXEC bit is set for the microMIPS ISA for the PIC32WK family
                                                  483:           # _bsc0 (_CP0_CONFIG3, _CP0_CONFIG3_SELECT, ISAONEXEC_MASK)
                                                  484:           li      t1,0x10000              # ISAONEXEC bit
                                                  485:           mfc0    t0,_CP0_CONFIG3
                                                  486:           or      t1,t0,t1
                                                  487:           mtc0    t1,_CP0_CONFIG3
                                                  488:   
                                                  489:   #endif /* PIC32WK && __mips_micromips */
                                                  490:   
                                                  491:   #if defined(INIT_FPU64) || defined(__PIC32_HAS_FPU64)
                                                  492:                                           # FPU Control and Status
                                                  493:           li      t2,0x1000000            # FCSR: RM=0, FS=1, FO=0, FN=0
                                                  494:                                           # Enables: 0b00000 E=1, V=0, Z=0, O=0, U=0, I=0
                                                  495:           ctc1    t2, $31                 # High perf on denormal operands & tiny results
                                                  496:   #endif
BFC00138  000000C0   EHB                          497:           ehb
                                                  498:   
                                                  499:           ##################################################################
                                                  500:           # Call the "on bootstrap" procedure
                                                  501:           ##################################################################
BFC0013C  3C089D00   LUI T0, -25344               502:           la      t0,_on_bootstrap
BFC00144  0100F809   JALR T0                      503:           jalr    t0
BFC00148  00000000   NOP                          504:           nop
                                                  505:   
                                                  506:           ##################################################################
                                                  507:           # Initialize Status<BEV> for normal exception vectors
                                                  508:           ##################################################################
BFC0014C  40086000   MFC0 T0, Status              509:           mfc0    t0,_CP0_STATUS
BFC00150  3C01FFBF   LUI AT, -65                  510:           and     t0,t0,0xffbfffff        # Clear BEV
BFC0015C  40886000   MTC0 T0, Status              511:           mtc0    t0,_CP0_STATUS
                                                  512:   
                                                  513:           ##################################################################
                                                  514:           # Call main. We do this via a thunk in the text section so that
                                                  515:           # a normal jump and link can be used, enabling the startup code
                                                  516:           # to work properly whether main is written in MIPS16 or MIPS32
                                                  517:           # code. I.e., the linker will correctly adjust the JAL to JALX if
                                                  518:           # necessary
                                                  519:           ##################################################################
BFC00160  30840000   ANDI A0, A0, 0               520:           and     a0,a0,0
BFC00164  30A50000   ANDI A1, A1, 0               521:           and     a1,a1,0
BFC00168  3C089D00   LUI T0, -25344               522:           la      t0,_main_entry
BFC00170  01000008   JR T0                        523:           jr      t0
BFC00174  00000000   NOP                          524:           nop
                                                  525:   
                                                  526:           .end _startup
                                                  527:   
                                                  528:           ##################################################################
                                                  529:           # Boot Exception Vector Handler
                                                  530:           # Jumps to _bootstrap_exception_handler
                                                  531:           ##################################################################
                                                  532:           .section .bev_handler,code,keep
                                                  533:           .align 2
                                                  534:           .set noreorder
                                                  535:           .ent _bev_exception
                                                  536:   _bev_exception:
BFC00380  3C1A9D00   LUI K0, -25344               537:           la        k0,_bootstrap_exception_handler
BFC00388  03400008   JR K0                        538:           jr        k0
BFC0038C  00000000   NOP                          539:           nop
                                                  540:   
                                                  541:           .end _bev_exception
                                                  542:   
                                                  543:           ##################################################################
                                                  544:           # General Exception Vector Handler
                                                  545:           # Jumps to _general_exception_context
                                                  546:           ##################################################################
                                                  547:           .section .gen_handler,code
                                                  548:           .align 2
                                                  549:           .set noreorder
                                                  550:           .ent _gen_exception
                                                  551:   _gen_exception:
9D00F180  3C1A9D00   LUI K0, -25344               552:   0:      la      k0,_general_exception_context
9D00F188  03400008   JR K0                        553:           jr      k0
9D00F18C  00000000   NOP                          554:           nop
                                                  555:   
                                                  556:           .end _gen_exception
                                                  557:   
                                                  558:   #if defined(INIT_MMU_MZ_FIXED) || defined(__PIC32_HAS_MMU_MZ_FIXED)
                                                  559:           ##################################################################
                                                  560:           # Simple TLB-Refill Exception Vector
                                                  561:           # Jumps to _simple_tlb_refill_exception_context
                                                  562:           ##################################################################
                                                  563:           .section .simple_tlb_refill_vector,code,keep
                                                  564:           .align 2
                                                  565:           .set noreorder
                                                  566:           .ent simple_tlb_refill_vector
                                                  567:   simple_tlb_refill_vector:
                                                  568:           la      k0,_simple_tlb_refill_exception_context
                                                  569:           jr      k0
                                                  570:           nop
                                                  571:   
                                                  572:           .end simple_tlb_refill_vector
                                                  573:   #endif
                                                  574:   
                                                  575:   #if defined(INIT_L1_CACHE) || defined(__PIC32_HAS_L1CACHE)
                                                  576:           ##################################################################
                                                  577:           # Cache-Error Exception Vector Handler
                                                  578:           # Jumps to _cache_err_exception_context
                                                  579:           ##################################################################
                                                  580:           .section .cache_err_vector,code,keep
                                                  581:           .align 2
                                                  582:           .set noreorder
                                                  583:           .ent _cache_err_vector
                                                  584:   _cache_err_vector:
                                                  585:           la      k0,_cache_err_exception_context
                                                  586:           jr      k0
                                                  587:           nop
                                                  588:   
                                                  589:           .end _cache_err_vector
                                                  590:   #endif
                                                  591:   
                                                  592:           .section .text.main_entry,code,keep
                                                  593:           .align 2
                                                  594:           .ent _main_entry
                                                  595:   _main_entry:
                                                  596:   
                                                  597:   #if defined(CPP_INIT)
                                                  598:           .weak _init
                                                  599:           # call .init section to run constructors etc
9D000378  3C040000   LUI A0, 0                    600:           lui	a0,%hi(_init)
9D00037C  27BDFFE8   ADDIU SP, SP, -24            601:           addiu	sp,sp,-24
9D000380  24840000   ADDIU A0, A0, 0              602:           addiu	a0,a0,%lo(_init)
9D000384  10800003   BEQ A0, ZERO, 0x9D000394     603:           beq	a0,$0,2f
9D000388  AFBF0014   SW RA, 20(SP)                604:           sw	$31,20(sp)	 #,
9D00038C  0080F809   JALR A0                      605:           jalr	a0
9D000390  00000000   NOP                          606:           nop
                                                  607:   2:
                                                  608:   #endif
9D000394  30840000   ANDI A0, A0, 0               609:           and     a0,a0,0
9D000398  30A50000   ANDI A1, A1, 0               610:           and     a1,a1,0
                                                  611:   
                                                  612:           ##################################################################
                                                  613:   
                                                  614:           # Call main
                                                  615:           ##################################################################
9D00039C  3C089D00   LUI T0, -25344               616:           la    	t0,main
9D0003A4  0100F809   JALR T0                      617:           jalr 	t0
9D0003A8  00000000   NOP                          618:           nop
                                                  619:   
                                                  620:   #if defined(CALL_EXIT)
                                                  621:           ##################################################################
                                                  622:           # Call exit()
                                                  623:           ##################################################################
                                                  624:           jal exit
                                                  625:           nop
                                                  626:   #endif
                                                  627:   
                                                  628:           ##################################################################
                                                  629:           # Just in case, go into infinite loop
                                                  630:           # Call a software breakpoint only with -mdebugger compiler option
                                                  631:           ##################################################################
                                                  632:           .weak __exception_handler_break
                                                  633:   __crt0_exit:
                                                  634:   1:
9D0003AC  3C029D00   LUI V0, -25344               635:           la      v0,__exception_handler_break
9D0003B4  10400003   BEQ V0, ZERO, 0x9D0003C4     636:           beq     v0,0,0f
9D0003B8  00000000   NOP                          637:           nop
9D0003BC  0040F809   JALR V0                      638:           jalr    v0
9D0003C0  00000000   NOP                          639:           nop
                                                  640:   
9D0003C4  1000FFF9   BEQ ZERO, ZERO, 0x9D0003AC   641:   0:      b       1b
9D0003C8  00000000   NOP                          642:           nop
                                                  643:   
                                                  644:           .globl __crt0_exit
                                                  645:           .end _main_entry
