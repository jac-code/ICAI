Disassembly Listing for Practica_4
Generated From:
C:/Users/jaime/Documents/GitHub/ICAI/TERCERO/Microprocesadores/Practica4/Practica_4.X/dist/default/debug/Practica_4.X.debug.elf
15-feb-2022 9:50:43

---  c:/users/jaime/documents/github/icai/tercero/microprocesadores/practica4/practica_4.x/inspeccionar_codigo.c
1:                   #include <xc.h>
2:                   
3:                   #define PIN_LED 0
4:                   #define PIN_PULSADOR 5
5:                    
6:                   int main (void) {
9D000188  27BDFFF0   ADDIU SP, SP, -16
9D00018C  AFBE000C   SW FP, 12(SP)
9D000190  03A0F021   ADDU FP, SP, ZERO
7:                       int valor_pulsador;
8:                       
9:                       // LED como salida, pulsador como entrada
10:                      TRISC &= ~(1 << PIN_LED);
9D000194  3C02BF88   LUI V0, -16504
9D000198  8C426210   LW V0, 25104(V0)
9D00019C  2404FFFE   ADDIU A0, ZERO, -2
9D0001A0  00441824   AND V1, V0, A0
9D0001A4  3C02BF88   LUI V0, -16504
9D0001A8  AC436210   SW V1, 25104(V0)
11:                      TRISB |= (1 << PIN_PULSADOR);
9D0001AC  3C02BF88   LUI V0, -16504
9D0001B0  8C426110   LW V0, 24848(V0)
9D0001B4  34430020   ORI V1, V0, 32
9D0001B8  3C02BF88   LUI V0, -16504
9D0001BC  AC436110   SW V1, 24848(V0)
12:                      
13:                      // LED empieza apagado
14:                      LATC |= (1 << PIN_LED);
9D0001C0  3C02BF88   LUI V0, -16504
9D0001C4  8C426230   LW V0, 25136(V0)
9D0001C8  34430001   ORI V1, V0, 1
9D0001CC  3C02BF88   LUI V0, -16504
9D0001D0  AC436230   SW V1, 25136(V0)
15:                     
16:                      while(1){
17:                          valor_pulsador = ( PORTB >> PIN_PULSADOR ) & 1;
9D0001D4  3C02BF88   LUI V0, -16504
9D0001D8  8C426120   LW V0, 24864(V0)
9D0001DC  00021142   SRL V0, V0, 5
9D0001E0  30420001   ANDI V0, V0, 1
9D0001E4  AFC20000   SW V0, 0(FP)
18:                         
19:                          // mientras el pulsador está pulsado = LED encendido
20:                          if(valor_pulsador == 0){
9D0001E8  8FC20000   LW V0, 0(FP)
9D0001EC  14400009   BNE V0, ZERO, 0x9D000214
9D0001F0  00000000   NOP
21:                              LATC &= ~(1 << PIN_LED);
9D0001F4  3C02BF88   LUI V0, -16504
9D0001F8  8C426230   LW V0, 25136(V0)
9D0001FC  2404FFFE   ADDIU A0, ZERO, -2
9D000200  00441824   AND V1, V0, A0
9D000204  3C02BF88   LUI V0, -16504
9D000208  AC436230   SW V1, 25136(V0)
22:                          } else {
23:                              LATC |= (1 << PIN_LED);
9D000214  3C02BF88   LUI V0, -16504
9D000218  8C426230   LW V0, 25136(V0)
9D00021C  34430001   ORI V1, V0, 1
9D000220  3C02BF88   LUI V0, -16504
9D000224  AC436230   SW V1, 25136(V0)
24:                          }
25:                      }
9D00020C  0B400075   J 0x9D0001D4
9D000210  00000000   NOP
9D000228  0B400075   J 0x9D0001D4
9D00022C  00000000   NOP
26:                  }
27:                  
---  C:/Users/jaime/OneDrive - Universidad Pontificia Comillas/ICAI/TERCERO/2_CUATRI/Microprocesadores/Laboratorio/LAB/P4Micro/Retardo.S
                                                  1:     #include <xc.h> 
                                                  2:     .text
                                                  3:     .global Retardo
                                                  4:     .ent Retardo 
                                                  5:     Retardo:
9D0000DC  10800028   BEQ A0, ZERO, 0x9D000180     6:         beq a0, zero, Fin	# comprobar si retardo = 0
9D0000E4  3C08BF80   LUI T0, -16512               7:         la t0, T2CON
9D0000EC  AD000000   SW ZERO, 0(T0)               8:         sw zero, 0(t0)  # T2CON=0
9D0000F0  3C08BF80   LUI T0, -16512               9:         la t0, TMR2
9D0000F8  AD000000   SW ZERO, 0(T0)               10:        sw zero, 0(t0)  # TMR2=0
9D0000FC  240DFDFF   ADDIU T5, ZERO, -513         11:        li t5, 0xFFFFFDFF   # Mascara para poner IFS0bits.T2IF = 0
9D000100  3C09BF88   LUI T1, -16504               12:        la t1, IFS0
9D000108  8D2A0000   LW T2, 0(T1)                 13:        lw t2, 0(t1)    # Cargo lo de IFS0
9D00010C  01AA5024   AND T2, T5, T2               14:        and t2, t5, t2  # Aplico mascara
9D000110  AD2A0000   SW T2, 0(T1)                 15:        sw t2, 0(t1)    # IFS0bits.T2IF=0
                                                  16:        addiu t0, zero, 0x1387    # 4999 en hexadecimal
9D000114  24081387   ADDIU T0, ZERO, 4999         17:        la t2, PR2
9D000120  AD480000   SW T0, 0(T2)                 18:        sw t0, 0(t2)    # PR2 = 4999;
9D000124  34088000   ORI T0, ZERO, -32768         19:        ori t0, zero, 0x8000
9D000128  3C0ABF80   LUI T2, -16512               20:        la t2, T2CON
9D000130  AD480000   SW T0, 0(T2)                 21:        sw t0, 0(t2)    # T2CON = 0x8000; 
9D000134  00001021   ADDU V0, ZERO, ZERO          22:        addu v0, zero, zero	# i=0
                                                  23:    For:
9D000138  0044402B   SLTU T0, V0, A0              24:        sltu t0, v0, a0 # t0 = 1 si i < retardo_ms
9D00013C  11000010   BEQ T0, ZERO, 0x9D000180     25:        beq t0, zero, Fin # si i < retardo_ms falso, salimos del bucle
9D000144  00000000   NOP                          26:        nop
                                                  27:    While:
9D000148  8D280000   LW T0, 0(T1)                 28:        lw t0, 0(t1)    # Leo en t0 el registro IFS0
9D00014C  240B0200   ADDIU T3, ZERO, 512          29:        li t3, 0x0200   # Mascara para poner todo a 0 menos el bit que me interesa
9D000150  010B6024   AND T4, T0, T3               30:        and t4, t0, t3  # Aplico mascara
9D000154  1180FFFC   BEQ T4, ZERO, 0x9D000148     31:        beq t4, zero, While	# Si todo es 0 ese bit que me interesa esta a 0
9D00015C  00000000   NOP                          32:        nop
9D000160  3C09BF88   LUI T1, -16504               33:        la t1, IFS0
9D000168  8D2A0000   LW T2, 0(T1)                 34:        lw t2, 0(t1)    # Cargo lo de IFS0
9D00016C  01AA5024   AND T2, T5, T2               35:        and t2, t5, t2  # Aplico mascara --> guardada en t5
9D000170  AD2A0000   SW T2, 0(T1)                 36:        sw t2, 0(t1)    # IFS0bits.T2IF = 0
                                                  37:        addi v0, v0, 1  # i++
9D000174  0B40004E   J 0x9D000138                 38:        j For
9D00017C  00000000   NOP                          39:        nop
                                                  40:    Fin:
9D000180  03E00008   JR RA                        41:        jr ra
                                                  42:        .end Retardo 
---  C:/Program Files/Microchip/MPLABX/v5.45/packs/Microchip/PIC32MX_DFP/1.3.231/xc32/startup/crt0.S  ---
                                                  1:     /*********************************************************************
                                                  2:      *
                                                  3:      *                  C Runtime Startup
                                                  4:      *
                                                  5:      *********************************************************************
                                                  6:      * Filename:        crt0.S
                                                  7:      *
                                                  8:      * Processor:       PIC32
                                                  9:      *
                                                  10:     * Compiler:        MPLAB XC32
                                                  11:     *                  MPLAB X IDE
                                                  12:     * Company:         Microchip Technology Inc.
                                                  13:     *
                                                  14:     * Software License Agreement
                                                  15:     *
                                                  16:     * Copyright (c) 2014, Microchip Technology Inc. and its subsidiaries ("Microchip")
                                                  17:     * All rights reserved.
                                                  18:     *
                                                  19:     * This software is developed by Microchip Technology Inc. and its
                                                  20:     * subsidiaries ("Microchip").
                                                  21:     *
                                                  22:     * Redistribution and use in source and binary forms, with or without
                                                  23:     * modification, are permitted provided that the following conditions are met:
                                                  24:     *
                                                  25:     * 1.      Redistributions of source code must retain the above copyright
                                                  26:     * notice, this list of conditions and the following disclaimer.
                                                  27:     *
                                                  28:     * 2.      Redistributions in binary form must reproduce the above copyright
                                                  29:     * notice, this list of conditions and the following disclaimer in the
                                                  30:     * documentation and/or other materials provided with the distribution.
                                                  31:     *
                                                  32:     * 3.      Microchip's name may not be used to endorse or promote products
                                                  33:     * derived from this software without specific prior written permission.
                                                  34:     *
                                                  35:     * THIS SOFTWARE IS PROVIDED BY MICROCHIP "AS IS" AND ANY EXPRESS OR IMPLIED
                                                  36:     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
                                                  37:     * MERCHANTABILITY AND FITNESS FOR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
                                                  38:     * MICROCHIP BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                                                  39:     * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING BUT NOT LIMITED TO
                                                  40:     * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA OR PROFITS;
                                                  41:     * OR BUSINESS INTERRUPTION) HOWSOEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                                                  42:     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
                                                  43:     * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
                                                  44:     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                  45:     *
                                                  46:     ********************************************************************/
                                                  47:    
                                                  48:    #include "xc.h"
                                                  49:    #include <cp0defs.h>
                                                  50:    
                                                  51:    #ifdef __LIBBUILD__
                                                  52:       # Replace the standard debugging information with a simple filename. This
                                                  53:       # prevents the library build directory from showing up in MPLAB IDE. It
                                                  54:       # also effectively disables source-line debugging.
                                                  55:       .file 1 "libpic32/startup/crt0.S"
                                                  56:       .loc 1 0
                                                  57:    #endif
                                                  58:    
                                                  59:    #if (__XC32_VERSION > 1000) && !defined(CPP_INIT)
                                                  60:    #define CPP_INIT
                                                  61:    #endif
                                                  62:    
                                                  63:    #if !defined(PIC32_SRS_SET_COUNT)
                                                  64:    #  if defined(__PIC32_SRS_SET_COUNT)
                                                  65:    #    define PIC32_SRS_SET_COUNT __PIC32_SRS_SET_COUNT
                                                  66:    #  else
                                                  67:    #    warning PIC32_SRS_SET_COUNT not defined on build line
                                                  68:    #    define PIC32_SRS_SET_COUNT 2
                                                  69:    #  endif
                                                  70:    #endif
                                                  71:    
                                                  72:    #if defined(__PIC32MX) || defined(__PIC32MM) || defined(__PIC32MZ)
                                                  73:    #define INIT_DATA 1
                                                  74:    #endif
                                                  75:    
                                                  76:    /* This file contains 32-bit assembly code */
                                                  77:           .set nomips16
                                                  78:    
                                                  79:            ##################################################################
                                                  80:            # Entry point of the entire application
                                                  81:            ##################################################################
                                                  82:            .section .reset,code,keep
                                                  83:            .align 2
                                                  84:            .set noreorder
                                                  85:            .ent _reset
                                                  86:    
                                                  87:    ############################
                                                  88:    # Begin ISA switching code #
                                                  89:    ############################
                                                  90:    
                                                  91:    #if defined (__mips_micromips)
                                                  92:            .set micromips
                                                  93:    #endif
                                                  94:    
                                                  95:    #if (defined(__PIC32_HAS_MICROMIPS)) && (defined(__PIC32_HAS_MIPS32R2))
                                                  96:    _reset:
                                                  97:            .word 0x10000003     /* MIPS32:    branch forward 0x10 bytes from here  */
                                                  98:                                 /* MicroMIPS: ADDI32 $0, $0, 0x0007 (nop)          */
                                                  99:                                 /* DO NOT change the relative branch               */
                                                  100:   
                                                  101:           .word 0x00000000     /* NOP */
                                                  102:   __reset_micromips_isa:
                                                  103:           .set    micromips
                                                  104:           jal     _startup
                                                  105:           nop
                                                  106:   
                                                  107:           .align 2
                                                  108:           /* Device not in proper ISA mode */
                                                  109:           .set nomicromips
                                                  110:   __reset_switch_isa:
                                                  111:           jal _startup
                                                  112:           nop
                                                  113:   
                                                  114:   #else
                                                  115:   
                                                  116:   _reset:
BFC00000  0FF00002   JAL 0xBFC00008               117:           jal _startup
BFC00004  00000000   NOP                          118:           nop
                                                  119:   
                                                  120:   #endif  /* __PIC32_HAS_MICROMIPS */
                                                  121:   
                                                  122:           .align 2
                                                  123:           .end _reset
                                                  124:           .globl _reset
                                                  125:           .size _reset, .-_reset
                                                  126:   
                                                  127:           .section .reset.startup,code,keep
                                                  128:           .align 2
                                                  129:           .set noreorder
                                                  130:   
                                                  131:   #if defined (__mips_micromips)
                                                  132:           .set micromips
                                                  133:   #else
                                                  134:           .set nomicromips
                                                  135:   #endif
                                                  136:   
                                                  137:   ############################
                                                  138:   # End ISA switching code   #
                                                  139:   ############################
                                                  140:   
                                                  141:           ##################################################################
                                                  142:           # Startup code
                                                  143:           ##################################################################
                                                  144:           .align 2
                                                  145:           .globl _startup
                                                  146:           .set noreorder
                                                  147:           .ent _startup
                                                  148:   _startup:
                                                  149:           ##################################################################
                                                  150:           # If entered because of an NMI, jump to the NMI handler.
                                                  151:           ##################################################################
BFC00008  401A6000   MFC0 K0, Status              152:           mfc0    k0,_CP0_STATUS
BFC0000C  7F5A04C0   EXT K0, K0, 19, 1            153:           ext     k0,k0,19,1              # Extract NMI bit
BFC00010  13400005   BEQ K0, ZERO, 0xBFC00028     154:           beqz    k0,_no_nmi
BFC00014  00000000   NOP                          155:           nop
BFC00018  3C1A9D00   LUI K0, -25344               156:           la      k0,_nmi_handler
BFC00020  03400008   JR K0                        157:           jr      k0
BFC00024  00000000   NOP                          158:           nop
                                                  159:   _no_nmi:
                                                  160:   
                                                  161:           ##################################################################
                                                  162:           # Initialize Stack Pointer
                                                  163:           #   _stack is initialized by the linker script to point to the
                                                  164:           #    starting location of the stack in DRM
                                                  165:           ##################################################################
BFC00028  3C1DA000   LUI SP, -24576               166:           la      sp,_stack
                                                  167:   
                                                  168:           ##################################################################
                                                  169:           # Initialize Global Pointer
                                                  170:           #   _gp is initialized by the linker script to point to "middle"
                                                  171:           #   of the small variables region
                                                  172:           ##################################################################
BFC00030  3C1CA001   LUI GP, -24575               173:           la      gp,_gp
                                                  174:   
                                                  175:   #if (PIC32_SRS_SET_COUNT == 2)
                                                  176:           ##################################################################
                                                  177:           # Initialize Global Pointer in Shadow Set
                                                  178:           #   The SRSCtl's PSS field must be set to the shadow set in which
                                                  179:           #   to initialize the global pointer.  Since we have only a
                                                  180:           #   single shadow set (besides the normal), we will initialize
                                                  181:           #   SRSCtl<PSS> to SRSCtl<HSS>.  We then write the global pointer
                                                  182:           #   to the previous shadow set to ensure that on interrupt, the
                                                  183:           #   global pointer has been initialized.
                                                  184:           ##################################################################
                                                  185:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
                                                  186:           add     t3,t1,zero              # Save off current SRSCtl
                                                  187:           ext     t2,t1,26,4              # to obtain HSS field
                                                  188:           ins     t1,t2,6,4               # Put HSS field
                                                  189:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
                                                  190:           ehb                             # Clear hazard before using new SRSCTL
                                                  191:           wrpgpr  gp,gp                   # Set global pointer in PSS
                                                  192:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
                                                  193:           ehb
                                                  194:   
                                                  195:   #elif (PIC32_SRS_SET_COUNT > 2)
                                                  196:           ##################################################################
                                                  197:           # Initialize Global Pointer in Shadow Set(s)
                                                  198:           #   The SRSCtl PSS field must be set to the shadow set in which
                                                  199:           #   to initialize the global pointer.  We will initialize
                                                  200:           #   SRSCtl<PSS> to the number of reg sets and work down to set zero.
                                                  201:           #   We write the global pointer to the previous shadow set to
                                                  202:           #   ensure that on interrupt, the global pointer has been
                                                  203:           #   initialized.
                                                  204:           ##################################################################
                                                  205:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
                                                  206:           add     t3,t1,zero              # Save off current SRSCtl
                                                  207:   
                                                  208:           li      t2,(PIC32_SRS_SET_COUNT-1)
                                                  209:   
                                                  210:   1:      ins     t1,t2,6,4               # Put next shadow set field
                                                  211:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
                                                  212:           ehb                             # Clear hazard before using new SRSCTL
                                                  213:           wrpgpr  gp,gp                   # Set global pointer in PSS
                                                  214:   
                                                  215:           addiu   t2,t2,-1                # Next lower shadow set
                                                  216:                                           # Loop for all sets
                                                  217:           bne     t2,$0,1b                # Down to zero (normal GPR set)
                                                  218:           nop
                                                  219:   
                                                  220:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
                                                  221:           ehb
                                                  222:   
                                                  223:   #endif /* (PIC32_SRS_SET_COUNT > 2) */
                                                  224:   
                                                  225:           ##################################################################
                                                  226:           # Call the "on reset" procedure
                                                  227:           ##################################################################
BFC00038  3C089D00   LUI T0, -25344               228:           la      t0,_on_reset
BFC00040  0100F809   JALR T0                      229:           jalr    t0
BFC00044  00000000   NOP                          230:           nop
                                                  231:   
                                                  232:   #if defined(INIT_MMU_MZ_FIXED) || defined(__PIC32_HAS_MMU_MZ_FIXED)
                                                  233:           ##################################################################
                                                  234:           # Initialize TLB for fixed mapping to EBI and SQI
                                                  235:           ##################################################################
                                                  236:           .extern __pic32_tlb_init_ebi_sqi
                                                  237:           la      t0,__pic32_tlb_init_ebi_sqi
                                                  238:           jalr    t0
                                                  239:           nop
                                                  240:   #endif
                                                  241:   
                                                  242:           ##################################################################
                                                  243:           # Clear uninitialized data sections
                                                  244:           ##################################################################
                                                  245:   _start_bss_init:
BFC00048  3C08A000   LUI T0, -24576               246:           la      t0,_bss_begin
BFC00050  3C09A000   LUI T1, -24576               247:           la      t1,_bss_end
BFC00058  10000003   BEQ ZERO, ZERO, 0xBFC00068   248:           b       _bss_check
BFC0005C  00000000   NOP                          249:           nop
                                                  250:   
                                                  251:   _bss_init:
BFC00060  AD000000   SW ZERO, 0(T0)               252:           sw      zero,0x0(t0)
BFC00064  25080004   ADDIU T0, T0, 4              253:           addu    t0,4
                                                  254:   _bss_check:
BFC00068  0109082B   SLTU AT, T0, T1              255:           bltu    t0,t1,_bss_init
BFC00070  00000000   NOP                          256:           nop
                                                  257:   
                                                  258:   #if defined(INIT_L1_CACHE) || defined(__PIC32_HAS_L1CACHE)
                                                  259:           ##################################################################
                                                  260:           # Initialize L1 cache. This must be done after bss clearing
                                                  261:           # since the _bss_end symbol may not be cache-line aligned.
                                                  262:           ##################################################################
                                                  263:           .extern   __pic32_init_cache
                                                  264:           la      t0,__pic32_init_cache
                                                  265:           jalr    t0
                                                  266:           nop
                                                  267:   #endif
                                                  268:   
                                                  269:   #if defined(INIT_DATA) || defined(__PIC32_HAS_INIT_DATA)
                                                  270:   
                                                  271:   #if defined(__LIBBUILD__) /* Prebuilt crt0.o file */
                                                  272:   
                                                  273:           ##################################################################
                                                  274:           # Initialize data using the linker-generated .dinit table
                                                  275:           # For use with XC32 versions prior to XC32 v2.10 only.
                                                  276:           ##################################################################
                                                  277:           .equiv FMT_CLEAR,0
                                                  278:           .equiv FMT_COPY,1
                                                  279:   _dinit_init:
                                                  280:           la      t0,_dinit_addr
                                                  281:   
                                                  282:   #define SRC t0
                                                  283:   #define DST t1
                                                  284:   #define LEN t2
                                                  285:   #define FMT t3
                                                  286:   
                                                  287:   0:      lw      DST,0(SRC)
                                                  288:           beqz    DST,9f
                                                  289:           addu    SRC,4
                                                  290:           lw      LEN,0(SRC)
                                                  291:           addu    SRC,4
                                                  292:           lw      FMT,0(SRC)
                                                  293:           beq     FMT,$0,_dinit_clear
                                                  294:           addu    SRC,4
                                                  295:   
                                                  296:   _dinit_copy:
                                                  297:           lbu     t4,0(SRC)
                                                  298:           subu    LEN,1
                                                  299:           addu    SRC,1
                                                  300:           sb      t4,0(DST)
                                                  301:           bne     LEN,$0,_dinit_copy
                                                  302:           addu    DST,1
                                                  303:   
                                                  304:           b       _dinit_end
                                                  305:           nop
                                                  306:   
                                                  307:   _dinit_clear:
                                                  308:           sb      $0,(DST)
                                                  309:           subu    LEN,1
                                                  310:           bne     LEN,$0,_dinit_clear
                                                  311:           addu    DST,1
                                                  312:   
                                                  313:   _dinit_end:
                                                  314:           addu    SRC,3
                                                  315:           addiu   LEN,$0,-4
                                                  316:           and     SRC,LEN,SRC
                                                  317:           lw      DST,0(SRC)
                                                  318:           bne     DST,$0,0b
                                                  319:           nop
                                                  320:   9:
                                                  321:   
                                                  322:   #else
                                                  323:           #####################################################################
                                                  324:           # Initialize data using the linker-generated .dinit table
                                                  325:           # XC32 v2.10 and later provide the data-init code in a separate file
                                                  326:           # packaged with the compiler rather than the DFP. Use that init
                                                  327:           # code instead.
                                                  328:           #####################################################################
                                                  329:           .extern   __pic32_data_init
BFC00074  3C089D00   LUI T0, -25344               330:           la      t0, __pic32_data_init
BFC0007C  0100F809   JALR T0                      331:           jalr    t0
BFC00080  00000000   NOP                          332:           nop
                                                  333:   
                                                  334:   #if defined(_OFF168_VOFF_POSITION)
                                                  335:           lui	t1,%hi(OFF168)
                                                  336:           lui	t2,%hi(__vector_offset_168)
                                                  337:           addiu	t2,t2,%lo(__vector_offset_168)
                                                  338:           sw	t2,%lo(OFF168)(t1)
                                                  339:   #endif
                                                  340:   
                                                  341:   #endif /* __LIBBUILD__ */
                                                  342:   
                                                  343:   #endif /* INIT_DATA */
                                                  344:   
                                                  345:           ##################################################################
                                                  346:           # If there are no RAM functions, skip the next section --
                                                  347:           # initializing bus matrix registers.
                                                  348:           ##################################################################
BFC00084  3C090000   LUI T1, 0                    349:           la      t1,_ramfunc_begin
BFC0008C  11200010   BEQ T1, ZERO, 0xBFC000D0     350:           beqz    t1,_ramfunc_done
BFC00090  00000000   NOP                          351:           nop
                                                  352:   
                                                  353:   #if defined(INIT_SSX) || defined(__PIC32_HAS_SSX)
                                                  354:     /* No initialization required */
                                                  355:   #else /* Use BMX */
                                                  356:           ##################################################################
                                                  357:           # Initialize bus matrix registers if RAM functions exist in the
                                                  358:           # application
                                                  359:           ##################################################################
BFC00094  3C090000   LUI T1, 0                    360:           la      t1,_bmxdkpba_address
BFC0009C  3C0ABF88   LUI T2, -16504               361:           la      t2,BMXDKPBA
BFC000A4  AD490000   SW T1, 0(T2)                 362:           sw      t1,0(t2)
BFC000A8  3C090000   LUI T1, 0                    363:           la      t1,_bmxdudba_address
BFC000B0  3C0ABF88   LUI T2, -16504               364:           la      t2,BMXDUDBA
BFC000B8  AD490000   SW T1, 0(T2)                 365:           sw      t1,0(t2)
BFC000BC  3C090000   LUI T1, 0                    366:           la      t1,_bmxdupba_address
BFC000C4  3C0ABF88   LUI T2, -16504               367:           la      t2,BMXDUPBA
BFC000CC  AD490000   SW T1, 0(T2)                 368:           sw      t1,0(t2)
                                                  369:   #endif /* INIT_SSX */
                                                  370:   
                                                  371:   _ramfunc_done:
                                                  372:   
                                                  373:           ##################################################################
                                                  374:           # Initialize CP0 registers
                                                  375:           ##################################################################
                                                  376:           # Initialize Count register
                                                  377:           ##################################################################
BFC000D0  40804800   MTC0 ZERO, Count             378:           mtc0    zero,_CP0_COUNT
                                                  379:   
                                                  380:           ##################################################################
                                                  381:           # Initialize Compare register
                                                  382:           ##################################################################
BFC000D4  240AFFFF   ADDIU T2, ZERO, -1           383:           li      t2,-1
BFC000D8  408A5800   MTC0 T2, Compare             384:           mtc0    t2,_CP0_COMPARE
                                                  385:   
                                                  386:           ##################################################################
                                                  387:           # Ensure BEV set and Initialize EBase register
                                                  388:           ##################################################################
BFC000DC  3C080040   LUI T0, 64                   389:           li      t0, (1<<22)
BFC000E0  400A6000   MFC0 T2, Status              390:           mfc0    t2,_CP0_STATUS
BFC000E4  010A5025   OR T2, T0, T2                391:           or      t2,t0,t2               # Set BEV bit 22
BFC000E8  408A6000   MTC0 T2, Status              392:           mtc0    t2,_CP0_STATUS
                                                  393:   
BFC000EC  3C099D01   LUI T1, -25343               394:           la      t1,_ebase_address
BFC000F4  000000C0   EHB                          395:           ehb
BFC000F8  40897801   MTC0 T1, EBase               396:           mtc0    t1,_CP0_EBASE
                                                  397:           
                                                  398:           ##################################################################
                                                  399:           # Initialize PRISS register to a safer default for devices that 
                                                  400:           # have it. The application should re-initialize it to an
                                                  401:           # application-specific value.
                                                  402:           #
                                                  403:           # We do NOT do this by default.
                                                  404:           ##################################################################
                                                  405:   #if defined(USE_DEFAULT_PRISS_VALUE) 
                                                  406:   #if defined(_PRISS_PRI7SS_POSITION)
                                                  407:   #if (PIC32_SRS_SET_COUNT >= 7)
                                                  408:           li	    t2, 0x76540000
                                                  409:           addiu	t2, t2, 0x3210
                                                  410:           lui	    t1, %hi(PRISS)
                                                  411:           sw	    t2, %lo(PRISS)(t1)
                                                  412:   #elif (PIC32_SRS_SET_COUNT <= 2)
                                                  413:           li	    t2, 0x10000000
                                                  414:           lui	    t1, %hi(PRISS)
                                                  415:           sw	    t2, %lo(PRISS)(t1)
                                                  416:   #endif /* PIC32_SRS_SET_COUNT */
                                                  417:   #endif /* _PRISS_PRI7SS_POSITION */
                                                  418:   #endif /* USE_DEFAULT_PRISS_VALUE */
                                                  419:           
                                                  420:           ##################################################################
                                                  421:           # Initialize IntCtl/INTCON.VS register with _vector_spacing
                                                  422:           ##################################################################
BFC000FC  3C090000   LUI T1, 0                    423:           la      t1,_vector_spacing
                                                  424:   #if defined(INIT_INTCONVS) || defined(__PIC32_HAS_INTCONVS)
                                                  425:           la      t0, INTCON
                                                  426:           lw      t2, 0(t0)
                                                  427:           li      t2, 0
                                                  428:           ins     t2, t1, 16, 7
                                                  429:   #if defined(__PIC32MM) && defined(_INTCON_MVEC_MASK)
                                                  430:           ori     t2, t2, _INTCON_MVEC_MASK
                                                  431:   #endif
                                                  432:           sw      t2, 0(t0)
                                                  433:   #endif
BFC00104  240A0000   ADDIU T2, ZERO, 0            434:           li      t2,0                    # Clear t2 and
BFC00108  7D2A4944   INS T2, T1, 5, 5             435:           ins     t2,t1,5,5               # shift value to VS field
BFC0010C  408A6001   MTC0 T2, IntCtl              436:           mtc0    t2,_CP0_INTCTL
                                                  437:   
                                                  438:           ##################################################################
                                                  439:           # Initialize CAUSE registers
                                                  440:           # - Enable counting of Count register <DC = 0>
                                                  441:           # - Use special exception vector <IV = 1>
                                                  442:           # - Clear pending software interrupts <IP1:IP0 = 0>
                                                  443:           ##################################################################
BFC00110  3C090080   LUI T1, 128                  444:           li      t1,0x00800000
BFC00114  40896800   MTC0 T1, Cause               445:           mtc0    t1,_CP0_CAUSE
                                                  446:   
                                                  447:           ##################################################################
                                                  448:           # Initialize STATUS register
                                                  449:           # - Access to Coprocessor 0 not allowed in user mode <CU0 = 0>
                                                  450:           # - User mode uses configured endianness <RE = 0>
                                                  451:           # - Preserve Bootstrap Exception vectors <BEV>
                                                  452:           # - Preserve soft reset <SR> and non-maskable interrupt <NMI>
                                                  453:           # - CorExtend enabled based on whether CorExtend User Defined
                                                  454:           #   Instructions have been implemented <CEE = Config<UDI>>
                                                  455:           # - Disable any pending interrupts <IM7..IM2 = 0, IM1..IM0 = 0>
                                                  456:           # - Disable hardware interrupts <IPL7:IPL2 = 0>
                                                  457:           # - Base mode is Kernel mode <UM = 0>
                                                  458:           # - Error level is normal <ERL = 0>
                                                  459:           # - Exception level is normal <EXL = 0>
                                                  460:           # - Interrupts are disabled <IE = 0>
                                                  461:           # - DSPr2 ASE is enabled for devices that support it <MX = 1>
                                                  462:           # - FPU64 is enabled for devices that support it <CU1=1> & <FR=1>
                                                  463:           ##################################################################
BFC00118  40088000   MFC0 T0, Config              464:           mfc0    t0,_CP0_CONFIG
BFC0011C  7D090580   EXT T1, T0, 22, 1            465:           ext     t1,t0,22,1              # Extract UDI from Config register
BFC00120  00094C40   SLL T1, T1, 17               466:           sll     t1,t1,17                # Move UDI to Status.CEE location
BFC00124  40086000   MFC0 T0, Status              467:           mfc0    t0,_CP0_STATUS
BFC00128  3C010058   LUI AT, 88                   468:           and     t0,t0,0x00580000        # Preserve SR, NMI, and BEV
                                                  469:   #if defined(INIT_DSPR2) || defined(__PIC32_HAS_DSPR2)
                                                  470:           li      t2, 0x01000000          # Set the Status.MX bit to enable DSP
                                                  471:           or      t0,t2,t0
                                                  472:   #endif
                                                  473:   #if defined(INIT_FPU64) || defined(__PIC32_HAS_FPU64)
                                                  474:           li      t2, 0x24000000          # Set the Status.CU1 and Status.FR bits to
                                                  475:           or      t0,t2,t0                # enable the FPU in FR64 mode
                                                  476:   #endif
                                                  477:   
BFC00130  01284025   OR T0, T1, T0                478:           or      t0,t1,t0                # Include Status.CEE (from UDI)
BFC00134  40886000   MTC0 T0, Status              479:           mtc0    t0,_CP0_STATUS
                                                  480:           
                                                  481:   #if defined(PIC32WK) && defined(_CP0_CONFIG3) && defined (__mips_micromips)
                                                  482:           # Ensure that the ISAONEXEC bit is set for the microMIPS ISA for the PIC32WK family
                                                  483:           # _bsc0 (_CP0_CONFIG3, _CP0_CONFIG3_SELECT, ISAONEXEC_MASK)
                                                  484:           li      t1,0x10000              # ISAONEXEC bit
                                                  485:           mfc0    t0,_CP0_CONFIG3
                                                  486:           or      t1,t0,t1
                                                  487:           mtc0    t1,_CP0_CONFIG3
                                                  488:   
                                                  489:   #endif /* PIC32WK && __mips_micromips */
                                                  490:   
                                                  491:   #if defined(INIT_FPU64) || defined(__PIC32_HAS_FPU64)
                                                  492:                                           # FPU Control and Status
                                                  493:           li      t2,0x1000000            # FCSR: RM=0, FS=1, FO=0, FN=0
                                                  494:                                           # Enables: 0b00000 E=1, V=0, Z=0, O=0, U=0, I=0
                                                  495:           ctc1    t2, $31                 # High perf on denormal operands & tiny results
                                                  496:   #endif
BFC00138  000000C0   EHB                          497:           ehb
                                                  498:   
                                                  499:           ##################################################################
                                                  500:           # Call the "on bootstrap" procedure
                                                  501:           ##################################################################
BFC0013C  3C089D00   LUI T0, -25344               502:           la      t0,_on_bootstrap
BFC00144  0100F809   JALR T0                      503:           jalr    t0
BFC00148  00000000   NOP                          504:           nop
                                                  505:   
                                                  506:           ##################################################################
                                                  507:           # Initialize Status<BEV> for normal exception vectors
                                                  508:           ##################################################################
BFC0014C  40086000   MFC0 T0, Status              509:           mfc0    t0,_CP0_STATUS
BFC00150  3C01FFBF   LUI AT, -65                  510:           and     t0,t0,0xffbfffff        # Clear BEV
BFC0015C  40886000   MTC0 T0, Status              511:           mtc0    t0,_CP0_STATUS
                                                  512:   
                                                  513:           ##################################################################
                                                  514:           # Call main. We do this via a thunk in the text section so that
                                                  515:           # a normal jump and link can be used, enabling the startup code
                                                  516:           # to work properly whether main is written in MIPS16 or MIPS32
                                                  517:           # code. I.e., the linker will correctly adjust the JAL to JALX if
                                                  518:           # necessary
                                                  519:           ##################################################################
BFC00160  30840000   ANDI A0, A0, 0               520:           and     a0,a0,0
BFC00164  30A50000   ANDI A1, A1, 0               521:           and     a1,a1,0
BFC00168  3C089D00   LUI T0, -25344               522:           la      t0,_main_entry
BFC00170  01000008   JR T0                        523:           jr      t0
BFC00174  00000000   NOP                          524:           nop
                                                  525:   
                                                  526:           .end _startup
                                                  527:   
                                                  528:           ##################################################################
                                                  529:           # Boot Exception Vector Handler
                                                  530:           # Jumps to _bootstrap_exception_handler
                                                  531:           ##################################################################
                                                  532:           .section .bev_handler,code,keep
                                                  533:           .align 2
                                                  534:           .set noreorder
                                                  535:           .ent _bev_exception
                                                  536:   _bev_exception:
BFC00380  3C1A9D00   LUI K0, -25344               537:           la        k0,_bootstrap_exception_handler
BFC00388  03400008   JR K0                        538:           jr        k0
BFC0038C  00000000   NOP                          539:           nop
                                                  540:   
                                                  541:           .end _bev_exception
                                                  542:   
                                                  543:           ##################################################################
                                                  544:           # General Exception Vector Handler
                                                  545:           # Jumps to _general_exception_context
                                                  546:           ##################################################################
                                                  547:           .section .gen_handler,code
                                                  548:           .align 2
                                                  549:           .set noreorder
                                                  550:           .ent _gen_exception
                                                  551:   _gen_exception:
9D00F180  3C1A9D00   LUI K0, -25344               552:   0:      la      k0,_general_exception_context
9D00F188  03400008   JR K0                        553:           jr      k0
9D00F18C  00000000   NOP                          554:           nop
                                                  555:   
                                                  556:           .end _gen_exception
                                                  557:   
                                                  558:   #if defined(INIT_MMU_MZ_FIXED) || defined(__PIC32_HAS_MMU_MZ_FIXED)
                                                  559:           ##################################################################
                                                  560:           # Simple TLB-Refill Exception Vector
                                                  561:           # Jumps to _simple_tlb_refill_exception_context
                                                  562:           ##################################################################
                                                  563:           .section .simple_tlb_refill_vector,code,keep
                                                  564:           .align 2
                                                  565:           .set noreorder
                                                  566:           .ent simple_tlb_refill_vector
                                                  567:   simple_tlb_refill_vector:
                                                  568:           la      k0,_simple_tlb_refill_exception_context
                                                  569:           jr      k0
                                                  570:           nop
                                                  571:   
                                                  572:           .end simple_tlb_refill_vector
                                                  573:   #endif
                                                  574:   
                                                  575:   #if defined(INIT_L1_CACHE) || defined(__PIC32_HAS_L1CACHE)
                                                  576:           ##################################################################
                                                  577:           # Cache-Error Exception Vector Handler
                                                  578:           # Jumps to _cache_err_exception_context
                                                  579:           ##################################################################
                                                  580:           .section .cache_err_vector,code,keep
                                                  581:           .align 2
                                                  582:           .set noreorder
                                                  583:           .ent _cache_err_vector
                                                  584:   _cache_err_vector:
                                                  585:           la      k0,_cache_err_exception_context
                                                  586:           jr      k0
                                                  587:           nop
                                                  588:   
                                                  589:           .end _cache_err_vector
                                                  590:   #endif
                                                  591:   
                                                  592:           .section .text.main_entry,code,keep
                                                  593:           .align 2
                                                  594:           .ent _main_entry
                                                  595:   _main_entry:
                                                  596:   
                                                  597:   #if defined(CPP_INIT)
                                                  598:           .weak _init
                                                  599:           # call .init section to run constructors etc
9D0002B4  3C040000   LUI A0, 0                    600:           lui	a0,%hi(_init)
9D0002B8  27BDFFE8   ADDIU SP, SP, -24            601:           addiu	sp,sp,-24
9D0002BC  24840000   ADDIU A0, A0, 0              602:           addiu	a0,a0,%lo(_init)
9D0002C0  10800003   BEQ A0, ZERO, 0x9D0002D0     603:           beq	a0,$0,2f
9D0002C4  AFBF0014   SW RA, 20(SP)                604:           sw	$31,20(sp)	 #,
9D0002C8  0080F809   JALR A0                      605:           jalr	a0
9D0002CC  00000000   NOP                          606:           nop
                                                  607:   2:
                                                  608:   #endif
9D0002D0  30840000   ANDI A0, A0, 0               609:           and     a0,a0,0
9D0002D4  30A50000   ANDI A1, A1, 0               610:           and     a1,a1,0
                                                  611:   
                                                  612:           ##################################################################
                                                  613:   
                                                  614:           # Call main
                                                  615:           ##################################################################
9D0002D8  3C089D00   LUI T0, -25344               616:           la    	t0,main
9D0002E0  0100F809   JALR T0                      617:           jalr 	t0
9D0002E4  00000000   NOP                          618:           nop
                                                  619:   
                                                  620:   #if defined(CALL_EXIT)
                                                  621:           ##################################################################
                                                  622:           # Call exit()
                                                  623:           ##################################################################
                                                  624:           jal exit
                                                  625:           nop
                                                  626:   #endif
                                                  627:   
                                                  628:           ##################################################################
                                                  629:           # Just in case, go into infinite loop
                                                  630:           # Call a software breakpoint only with -mdebugger compiler option
                                                  631:           ##################################################################
                                                  632:           .weak __exception_handler_break
                                                  633:   __crt0_exit:
                                                  634:   1:
9D0002E8  3C029D00   LUI V0, -25344               635:           la      v0,__exception_handler_break
9D0002F0  10400003   BEQ V0, ZERO, 0x9D000300     636:           beq     v0,0,0f
9D0002F4  00000000   NOP                          637:           nop
9D0002F8  0040F809   JALR V0                      638:           jalr    v0
9D0002FC  00000000   NOP                          639:           nop
                                                  640:   
9D000300  1000FFF9   BEQ ZERO, ZERO, 0x9D0002E8   641:   0:      b       1b
9D000304  00000000   NOP                          642:           nop
                                                  643:   
                                                  644:           .globl __crt0_exit
                                                  645:           .end _main_entry
